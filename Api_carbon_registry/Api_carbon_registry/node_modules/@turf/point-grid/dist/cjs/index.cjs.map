{"version":3,"sources":["../../index.ts"],"names":[],"mappings":";;;;AASA,SAAS,iBAAiB,cAAc;AACxC,SAAS,gBAAgB;AACzB,SAAS,OAAO,yBAAgC;AAuBhD,SAAS,UACP,MACA,UACA,UAII,CAAC,GACwB;AAE7B,MAAI,QAAQ,QAAQ,CAAC,QAAQ;AAAO,YAAQ,QAAQ;AAGpD,MAAI,UAAU,CAAC;AAUf,MAAI,OAAO,KAAK,CAAC;AACjB,MAAI,QAAQ,KAAK,CAAC;AAClB,MAAI,OAAO,KAAK,CAAC;AACjB,MAAI,QAAQ,KAAK,CAAC;AAElB,MAAI,YAAY,WAAW,SAAS,CAAC,MAAM,KAAK,GAAG,CAAC,MAAM,KAAK,GAAG,OAAO;AACzE,MAAI,YAAY,aAAa,OAAO;AACpC,MAAI,YAAY,WAAW,SAAS,CAAC,MAAM,KAAK,GAAG,CAAC,MAAM,KAAK,GAAG,OAAO;AACzE,MAAI,aAAa,aAAa,QAAQ;AAEtC,MAAI,YAAY,OAAO;AACvB,MAAI,aAAa,QAAQ;AACzB,MAAI,UAAU,KAAK,MAAM,YAAY,SAAS;AAC9C,MAAI,OAAO,KAAK,MAAM,aAAa,UAAU;AAG7C,MAAI,UAAU,YAAY,UAAU,aAAa;AACjD,MAAI,UAAU,aAAa,OAAO,cAAc;AAEhD,MAAI,WAAW,OAAO;AACtB,SAAO,YAAY,MAAM;AACvB,QAAI,WAAW,QAAQ;AACvB,WAAO,YAAY,OAAO;AACxB,UAAI,SAAS,MAAM,CAAC,UAAU,QAAQ,GAAG,QAAQ,UAAU;AAC3D,UAAI,QAAQ,MAAM;AAChB,YAAI,OAAO,QAAQ,QAAQ,IAAI;AAAG,kBAAQ,KAAK,MAAM;AAAA,MACvD,OAAO;AACL,gBAAQ,KAAK,MAAM;AAAA,MACrB;AACA,kBAAY;AAAA,IACd;AACA,gBAAY;AAAA,EACd;AAEA,SAAO,kBAAkB,OAAO;AAClC;AA1DS;AA6DT,IAAO,0BAAQ","sourcesContent":["import {\n  BBox,\n  Feature,\n  Polygon,\n  MultiPolygon,\n  FeatureCollection,\n  Point,\n  GeoJsonProperties,\n} from \"geojson\";\nimport { booleanWithin as within } from \"@turf/boolean-within\";\nimport { distance } from \"@turf/distance\";\nimport { point, featureCollection, Units } from \"@turf/helpers\";\n\n/**\n * Creates a {@link Point} grid from a bounding box, {@link FeatureCollection} or {@link Feature}.\n *\n * @name pointGrid\n * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order\n * @param {number} cellSide the distance between points, in units\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] used in calculating cellSide, can be degrees, radians, miles, or kilometers\n * @param {Feature<Polygon|MultiPolygon>} [options.mask] if passed a Polygon or MultiPolygon, the grid Points will be created only inside it\n * @param {Object} [options.properties={}] passed to each point of the grid\n * @returns {FeatureCollection<Point>} grid of points\n * @example\n * var extent = [-70.823364, -33.553984, -70.473175, -33.302986];\n * var cellSide = 3;\n * var options = {units: 'miles'};\n *\n * var grid = turf.pointGrid(extent, cellSide, options);\n *\n * //addToMap\n * var addToMap = [grid];\n */\nfunction pointGrid<P extends GeoJsonProperties = GeoJsonProperties>(\n  bbox: BBox,\n  cellSide: number,\n  options: {\n    units?: Units;\n    mask?: Feature<Polygon | MultiPolygon>;\n    properties?: P;\n  } = {}\n): FeatureCollection<Point, P> {\n  // Default parameters\n  if (options.mask && !options.units) options.units = \"kilometers\";\n\n  // Containers\n  var results = [];\n\n  // Typescript handles the Type Validation\n  // if (cellSide === null || cellSide === undefined) throw new Error('cellSide is required');\n  // if (!isNumber(cellSide)) throw new Error('cellSide is invalid');\n  // if (!bbox) throw new Error('bbox is required');\n  // if (!Array.isArray(bbox)) throw new Error('bbox must be array');\n  // if (bbox.length !== 4) throw new Error('bbox must contain 4 numbers');\n  // if (mask && ['Polygon', 'MultiPolygon'].indexOf(getType(mask)) === -1) throw new Error('options.mask must be a (Multi)Polygon');\n\n  var west = bbox[0];\n  var south = bbox[1];\n  var east = bbox[2];\n  var north = bbox[3];\n\n  var xFraction = cellSide / distance([west, south], [east, south], options);\n  var cellWidth = xFraction * (east - west);\n  var yFraction = cellSide / distance([west, south], [west, north], options);\n  var cellHeight = yFraction * (north - south);\n\n  var bboxWidth = east - west;\n  var bboxHeight = north - south;\n  var columns = Math.floor(bboxWidth / cellWidth);\n  var rows = Math.floor(bboxHeight / cellHeight);\n\n  // adjust origin of the grid\n  var deltaX = (bboxWidth - columns * cellWidth) / 2;\n  var deltaY = (bboxHeight - rows * cellHeight) / 2;\n\n  var currentX = west + deltaX;\n  while (currentX <= east) {\n    var currentY = south + deltaY;\n    while (currentY <= north) {\n      var cellPt = point([currentX, currentY], options.properties);\n      if (options.mask) {\n        if (within(cellPt, options.mask)) results.push(cellPt);\n      } else {\n        results.push(cellPt);\n      }\n      currentY += cellHeight;\n    }\n    currentX += cellWidth;\n  }\n\n  return featureCollection(results);\n}\n\nexport { pointGrid };\nexport default pointGrid;\n"]}