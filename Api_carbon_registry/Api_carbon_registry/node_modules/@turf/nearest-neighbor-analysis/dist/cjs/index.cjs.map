{"version":3,"sources":["../../index.ts"],"names":[],"mappings":";;;;AAOA,SAAS,YAAY;AACrB,SAAS,YAAY;AACrB,SAAS,mBAAmB;AAC5B,SAAS,gBAAgB;AACzB,SAAS,gBAAgB;AACzB,SAAS,oBAAoB;AAC7B,SAAS,mBAAmB;AAC5B;AAAA,EACE;AAAA,EACA;AAAA,OAGK;AAqEP,SAAS,wBACP,SACA,SAK0B;AAE1B,YAAU,WAAW,CAAC;AACtB,QAAM,YAAY,QAAQ,aAAa,YAAY,KAAK,OAAO,CAAC;AAChE,QAAM,aAAa,QAAQ,cAAc,CAAC;AAC1C,QAAM,QAAQ,QAAQ,SAAS;AAE/B,QAAM,WAAkC,CAAC;AACzC,cAAY,SAAS,CAAC,YAAY;AAChC,aAAS,KAAK,SAAS,OAAO,CAAC;AAAA,EACjC,CAAC;AACD,QAAM,IAAI,SAAS;AACnB,QAAM,uBACJ,SACG,IAAI,CAAC,SAAS,UAAU;AACvB,UAAM,gBAAgB;AAAA,MACpB,SAAS,OAAO,CAAC,GAAG,MAAM;AACxB,eAAO,MAAM;AAAA,MACf,CAAC;AAAA,IACH;AAGA,WAAO;AAAA,MACL;AAAA,MACA,aAAa,SAAS,aAAa,EAAE,SAAU;AAAA,MAC/C,EAAE,MAAM;AAAA,IACV;AAAA,EACF,CAAC,EACA,OAAO,CAAC,KAAK,UAAU;AACtB,WAAO,MAAM;AAAA,EACf,GAAG,CAAC,IAAI;AAEZ,QAAM,oBAAoB,IAAI,YAAY,KAAK,SAAS,GAAG,UAAU,KAAK;AAC1E,QAAM,uBAAuB,KAAK,IAAI,KAAK,KAAK,iBAAiB;AACjE,QAAM,WAAW,UAAU,KAAK,KAAK,IAAI,iBAAiB;AAC1D,aAAW,0BAA0B;AAAA,IACnC;AAAA,IACA,YAAY,QAAQ;AAAA,IACpB;AAAA,IACA;AAAA,IACA,sBAAsB,uBAAuB;AAAA,IAC7C,gBAAgB;AAAA,IAChB,SAAS,uBAAuB,wBAAwB;AAAA,EAC1D;AACA,YAAU,aAAa;AAEvB,SAAO;AACT;AAtDS;AA6DT,IAAO,yCAAQ","sourcesContent":["import {\n  FeatureCollection,\n  Feature,\n  Point,\n  Polygon,\n  GeoJsonProperties,\n} from \"geojson\";\nimport { area } from \"@turf/area\";\nimport { bbox } from \"@turf/bbox\";\nimport { bboxPolygon } from \"@turf/bbox-polygon\";\nimport { centroid } from \"@turf/centroid\";\nimport { distance } from \"@turf/distance\";\nimport { nearestPoint } from \"@turf/nearest-point\";\nimport { featureEach } from \"@turf/meta\";\nimport {\n  convertArea,\n  featureCollection,\n  Units,\n  AreaUnits,\n} from \"@turf/helpers\";\n\ninterface NearestNeighborStatistics {\n  units: Units & AreaUnits;\n  arealUnits: string;\n  observedMeanDistance: number;\n  expectedMeanDistance: number;\n  numberOfPoints: number;\n  zScore: number;\n}\n\ninterface NearestNeighborStudyArea extends Feature<Polygon> {\n  properties: {\n    nearestNeighborAnalysis: NearestNeighborStatistics;\n    [key: string]: any;\n  };\n}\n\n/**\n * Nearest Neighbor Analysis calculates an index based the average distances\n * between points in the dataset, thereby providing inference as to whether the\n * data is clustered, dispersed, or randomly distributed within the study area.\n *\n * It returns a {@link Feature<Polygon>} of the study area, with the results of\n * the analysis attached as part of of the `nearestNeighborAnalysis` property\n * of the study area's `properties`. The attached\n * [_z_-score](https://en.wikipedia.org/wiki/Standard_score) indicates how many\n * standard deviations above or below the expected mean distance the data's\n * observed mean distance is. The more negative, the more clustered. The more\n * positive, the more evenly dispersed. A _z_-score between -2 and 2 indicates\n * a seemingly random distribution. That is, within _p_ of less than 0.05, the\n * distribution appears statistically significantly neither clustered nor\n * dispersed.\n *\n * **Remarks**\n *\n * - Though the analysis will work on any {@link FeatureCollection} type, it\n * works best with {@link Point} collections.\n *\n * - This analysis is _very_ sensitive to the study area provided.\n * If no {@link Feature<Polygon>} is passed as the study area, the function draws a box\n * around the data, which may distort the findings. This analysis works best\n * with a bounded area of interest within with the data is either clustered,\n * dispersed, or randomly distributed. For example, a city's subway stops may\n * look extremely clustered if the study area is an entire state. On the other\n * hand, they may look rather evenly dispersed if the study area is limited to\n * the city's downtown.\n *\n * **Bibliography**\n *\n * Philip J. Clark and Francis C. Evans, “Distance to Nearest Neighbor as a\n * Measure of Spatial Relationships in Populations,” _Ecology_ 35, no. 4\n * (1954): 445–453, doi:[10.2307/1931034](http://doi.org/10.2307/1931034).\n *\n * @name nearestNeighborAnalysis\n * @param {FeatureCollection<any>} dataset FeatureCollection (pref. of points) to study\n * @param {Object} [options={}] Optional parameters\n * @param {Feature<Polygon>} [options.studyArea] polygon representing the study area\n * @param {string} [options.units='kilometers'] unit of measurement for distances and, squared, area.\n * @param {Object} [options.properties={}] properties\n * @returns {Feature<Polygon>} A polygon of the study area or an approximation of one.\n * @example\n * var bbox = [-65, 40, -63, 42];\n * var dataset = turf.randomPoint(100, { bbox: bbox });\n * var nearestNeighborStudyArea = turf.nearestNeighborAnalysis(dataset);\n *\n * //addToMap\n * var addToMap = [dataset, nearestNeighborStudyArea];\n */\nfunction nearestNeighborAnalysis(\n  dataset: FeatureCollection<any>,\n  options?: {\n    studyArea?: Feature<Polygon>;\n    units?: Units & AreaUnits;\n    properties?: GeoJsonProperties;\n  }\n): NearestNeighborStudyArea {\n  // Optional params\n  options = options || {};\n  const studyArea = options.studyArea || bboxPolygon(bbox(dataset));\n  const properties = options.properties || {};\n  const units = options.units || \"kilometers\";\n\n  const features: Array<Feature<Point>> = [];\n  featureEach(dataset, (feature) => {\n    features.push(centroid(feature));\n  });\n  const n = features.length;\n  const observedMeanDistance =\n    features\n      .map((feature, index) => {\n        const otherFeatures = featureCollection<Point>(\n          features.filter((f, i) => {\n            return i !== index;\n          })\n        );\n        // Have to add the ! to make typescript validation pass\n        // see https://stackoverflow.com/a/40350534/1979085\n        return distance(\n          feature,\n          nearestPoint(feature, otherFeatures).geometry!.coordinates,\n          { units }\n        );\n      })\n      .reduce((sum, value) => {\n        return sum + value;\n      }, 0) / n;\n\n  const populationDensity = n / convertArea(area(studyArea), \"meters\", units);\n  const expectedMeanDistance = 1 / (2 * Math.sqrt(populationDensity));\n  const variance = 0.26136 / Math.sqrt(n * populationDensity);\n  properties.nearestNeighborAnalysis = {\n    units: units,\n    arealUnits: units + \"²\",\n    observedMeanDistance: observedMeanDistance,\n    expectedMeanDistance: expectedMeanDistance,\n    nearestNeighborIndex: observedMeanDistance / expectedMeanDistance,\n    numberOfPoints: n,\n    zScore: (observedMeanDistance - expectedMeanDistance) / variance,\n  };\n  studyArea.properties = properties;\n\n  return studyArea as NearestNeighborStudyArea;\n}\n\nexport {\n  nearestNeighborAnalysis,\n  NearestNeighborStatistics,\n  NearestNeighborStudyArea,\n};\nexport default nearestNeighborAnalysis;\n"]}