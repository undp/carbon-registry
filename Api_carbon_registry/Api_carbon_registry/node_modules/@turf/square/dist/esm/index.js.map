{"version":3,"sources":["../../index.js"],"sourcesContent":["import { distance } from \"@turf/distance\";\n\n/**\n * Takes a bounding box and calculates the minimum square bounding box that\n * would contain the input.\n *\n * @name square\n * @param {BBox} bbox extent in [west, south, east, north] order\n * @returns {BBox} a square surrounding `bbox`\n * @example\n * var bbox = [-20, -20, -15, 0];\n * var squared = turf.square(bbox);\n *\n * //addToMap\n * var addToMap = [turf.bboxPolygon(bbox), turf.bboxPolygon(squared)]\n */\nfunction square(bbox) {\n  var west = bbox[0];\n  var south = bbox[1];\n  var east = bbox[2];\n  var north = bbox[3];\n\n  var horizontalDistance = distance(bbox.slice(0, 2), [east, south]);\n  var verticalDistance = distance(bbox.slice(0, 2), [west, north]);\n  if (horizontalDistance >= verticalDistance) {\n    var verticalMidpoint = (south + north) / 2;\n    return [\n      west,\n      verticalMidpoint - (east - west) / 2,\n      east,\n      verticalMidpoint + (east - west) / 2,\n    ];\n  } else {\n    var horizontalMidpoint = (west + east) / 2;\n    return [\n      horizontalMidpoint - (north - south) / 2,\n      south,\n      horizontalMidpoint + (north - south) / 2,\n      north,\n    ];\n  }\n}\n\nexport { square };\nexport default square;\n"],"mappings":";;;;AAAA,SAAS,gBAAgB;AAgBzB,SAAS,OAAO,MAAM;AACpB,MAAI,OAAO,KAAK,CAAC;AACjB,MAAI,QAAQ,KAAK,CAAC;AAClB,MAAI,OAAO,KAAK,CAAC;AACjB,MAAI,QAAQ,KAAK,CAAC;AAElB,MAAI,qBAAqB,SAAS,KAAK,MAAM,GAAG,CAAC,GAAG,CAAC,MAAM,KAAK,CAAC;AACjE,MAAI,mBAAmB,SAAS,KAAK,MAAM,GAAG,CAAC,GAAG,CAAC,MAAM,KAAK,CAAC;AAC/D,MAAI,sBAAsB,kBAAkB;AAC1C,QAAI,oBAAoB,QAAQ,SAAS;AACzC,WAAO;AAAA,MACL;AAAA,MACA,oBAAoB,OAAO,QAAQ;AAAA,MACnC;AAAA,MACA,oBAAoB,OAAO,QAAQ;AAAA,IACrC;AAAA,EACF,OAAO;AACL,QAAI,sBAAsB,OAAO,QAAQ;AACzC,WAAO;AAAA,MACL,sBAAsB,QAAQ,SAAS;AAAA,MACvC;AAAA,MACA,sBAAsB,QAAQ,SAAS;AAAA,MACvC;AAAA,IACF;AAAA,EACF;AACF;AAzBS;AA4BT,IAAO,sBAAQ;","names":[]}